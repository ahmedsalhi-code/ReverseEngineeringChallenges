/*
 * SecurinetsENIT CTF 2025 - Reverse Engineering Challenge
 * "Layered"
 *
 * Difficulty: Intermediate
 * Author: [your handle]
 *
 * Flag format: SecurinetsENIT{...}
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

/* ─────────────────────────────────────────────
 * RED HERRING #1 — "decrypt_hint"
 *
 * This function looks like it XORs something with
 * 0x42 and prints a "hint". It runs unconditionally
 * at startup and produces output that makes players
 * think the key is 0x42. The output is completely
 * unrelated to the actual flag check.
 * ───────────────────────────────────────────── */
void decrypt_hint(void) {
    /* Looks important, but this is bait.
     * The string decodes to: "key = B"  (0x42 == 'B')
     * which misleads solvers into thinking XOR key is 0x42 */
    unsigned char fake[] = { 0x29, 0x2b, 0xf0, 0x73, 0x62, 0x60, 0x62 };
    for (int i = 0; i < (int)sizeof(fake); i++)
        fake[i] ^= 0x42;
    printf("[*] Initialization: %s\n", fake);
}

/* ─────────────────────────────────────────────
 * RED HERRING #2 — fake_check()
 *
 * A strcmp-based check that fires before the real
 * check. Decompilers show this prominently. It
 * compares input to a hardcoded string "S3cur1n3ts"
 * which looks like a password but is irrelevant.
 * Passing this check does NOT help: the real check
 * runs independently regardless.
 * ───────────────────────────────────────────── */
int fake_check(const char *input) {
    /* Bait: solvers may patch the branch or feed
     * "S3cur1n3ts" — neither helps them find the flag */
    if (strcmp(input, "S3cur1n3ts") == 0) {
        printf("[+] Access granted. Decrypting...\n");
        /* Prints garbage on purpose to waste time */
        printf("    Flag: SecurinetsENIT{n0t_th3_fl4g_k33p_l00k1ng}\n");
        return 1;
    }
    return 0;
}

/* ─────────────────────────────────────────────
 * STAGE 1 — XOR with position-dependent key
 *
 * Each byte is XORed with (index % 7 + 3).
 * The key rotates every 7 bytes: 3,4,5,6,7,8,9,3,4,...
 * Trick: not a fixed XOR key, so strings view
 * in a hex editor won't reveal it with simple XOR.
 * ───────────────────────────────────────────── */
static void stage1(const unsigned char *in, unsigned char *out, int len) {
    for (int i = 0; i < len; i++)
        out[i] = in[i] ^ (unsigned char)((i % 7) + 3);
}

/* ─────────────────────────────────────────────
 * STAGE 2 — Feedback-dependent rotate-left
 *
 * Each byte is rotated left by (running_sum % 5 + 1)
 * bits, where running_sum accumulates stage1 output.
 * The rotation amount depends on ALL previous bytes,
 * so the transformation is non-linear and cannot be
 * inverted byte-by-byte in isolation without tracking
 * the running sum.
 * ───────────────────────────────────────────── */
static unsigned char rotl8(unsigned char v, int n) {
    n &= 7;
    return (v << n) | (v >> (8 - n));
}

static void stage2(const unsigned char *in, unsigned char *out, int len) {
    unsigned int running_sum = 0;
    for (int i = 0; i < len; i++) {
        int rot = (int)(running_sum % 5) + 1;
        out[i] = rotl8(in[i], rot);
        running_sum += in[i];   /* accumulate STAGE1 value (before rotation) */
    }
}

/* ─────────────────────────────────────────────
 * STAGE 3 — Inter-byte additive mixing
 *
 * out[0] = stage2[0]  (unchanged)
 * out[i] = (stage2[i] + (stage2[i-1] ^ 0xAA)) & 0xFF
 *
 * This chains bytes together so a single wrong input
 * character corrupts all subsequent output bytes.
 * Makes differential/bruteforce harder.
 * ───────────────────────────────────────────── */
static void stage3(const unsigned char *in, unsigned char *out, int len) {
    out[0] = in[0];
    for (int i = 1; i < len; i++)
        out[i] = (unsigned char)((in[i] + (in[i-1] ^ 0xAA)) & 0xFF);
}

/* ─────────────────────────────────────────────
 * TARGET BLOB
 *
 * The correct flag, after passing through all three
 * stages, must equal this byte array exactly.
 * Generated by: encode(flag) → stage1 → stage2 → stage3
 * ───────────────────────────────────────────── */
static const unsigned char target[] = {
    0xa0, 0xcc, 0x9b, 0x07, 0x72, 0x89, 0xa5, 0x75,
    0x3a, 0x99, 0x7a, 0x30, 0x4c, 0x93, 0x60, 0x24,
    0x39, 0x73, 0x15, 0x95, 0xc8, 0xad, 0x0b, 0x16,
    0x6b, 0xde, 0x23, 0x76, 0xac, 0xc6, 0xfb, 0xff
};

#define FLAG_LEN 32

int main(void) {
    char input[256];

    /* Red herring #1: prints misleading "key = B" */
    decrypt_hint();

    printf("Enter flag: ");
    if (!fgets(input, sizeof(input), stdin))
        return 1;

    /* Strip newline */
    int n = (int)strlen(input);
    if (n > 0 && input[n-1] == '\n')
        input[--n] = '\0';

    /* Red herring #2: fake strcmp check — bait for patchers */
    fake_check(input);

    /* Reject wrong length early (mildly informative, but length of
     * "SecurinetsENIT{...}" is obvious from the format anyway) */
    if (n != FLAG_LEN) {
        printf("[-] Wrong.\n");
        return 1;
    }

    unsigned char buf1[FLAG_LEN];
    unsigned char buf2[FLAG_LEN];
    unsigned char buf3[FLAG_LEN];

    stage1((unsigned char *)input, buf1, FLAG_LEN);
    stage2(buf1, buf2, FLAG_LEN);
    stage3(buf2, buf3, FLAG_LEN);

    if (memcmp(buf3, target, FLAG_LEN) == 0)
        printf("[+] Correct! Flag accepted.\n");
    else
        printf("[-] Wrong.\n");

    return 0;
}
